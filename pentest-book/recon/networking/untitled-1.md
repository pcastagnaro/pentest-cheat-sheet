# Network Discovery

## Nmap

{% hint style="info" %}
For [Nmap Docker](untitled-1.md#nmap-docker)
{% endhint %}

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>sudo nmap -sS -Pn -v -A -p- --min-parallelism 20 --min-hostgroup 30 --max-rtt-timeout 30ms --version all --max-retries 2 -oA SYNAllPorts -sC --script broadcast,discovery Network
</strong></code></pre>

{% hint style="info" %}
`--allports` (Don't exclude any ports from version detection)

`--version all` Enable intensity level 9. Higher possibility of correctness. Slower

`-A` Enables OS detection, version detection, script scanning, and traceroute

`--script discovery` Try to learn more information about target hosts through public sources of information, SNMP, directory services, and more

`--script broadcast` Discover hosts not included on command line by broadcasting on local network.
{% endhint %}

{% code overflow="wrap" lineNumbers="true" %}
```bash
sudo nmap -PE -PP -PM --min-parallelism 20 --min-hostgroup 30 --max-rtt-timeout 30ms --max-retries 2 -A -oA HostDiscoveryMultpleICMP Network
```
{% endcode %}

{% hint style="info" %}
`-PE` Use ICMP Echo Request

`-PP:` Use ICMP Timestamp Request

`-PM:` Use ICMP Netmask Request
{% endhint %}



{% hint style="info" %}
Nmap to Markdown: [Nmap2md](https://app.gitbook.com/o/5S34jejP8cj7fWWt6R2a/s/-Lt8335BPUBXjq3iC572/pentest-book/parsing-reporting/parsing#nmap2md)
{% endhint %}

### Nmap Docker

Using the [https://hub.docker.com/r/instrumentisto/nmap](https://hub.docker.com/r/instrumentisto/nmap)

{% code overflow="wrap" lineNumbers="true" %}
```bash
docker run --rm -it -v "C:\localFolder\nmap:/output" instrumentisto/nmap -v -sS --top-ports 8000 --max-retries 2 -sV -oA /output/[OUTPUT NAME] [DOMAIN]
```
{% endcode %}

***

## sn1per

**Repository:** [https://github.com/1N3/Sn1per](https://github.com/1N3/Sn1per)

**Info:** Automated Pentest Recon Scanner

### **DISCOVER**

Parses all hosts on a subnet/CIDR (ie. `192.168.0.0/16`) and initiates a sniper scan against each host. Useful for internal network scans.

```
sudo sniper -t <CIDR> -m discover -w <WORSPACE_ALIAS>
sudo sniper -t www.domain.com -m discover -w workspace_name
```

### **AIRSTRIKE**

Quickly enumerates open ports/services on multiple hosts and performs basic fingerprinting. To use, specify the full location of the file which contains all hosts, IPs that need to be scanned and run `./sn1per /full/path/to/targets.txt` airstrike to begin scanning.

```
sudo sniper -f /full/path/to/targets.txt -m airstrike
sudo sniper -t domain.com | <CIDR> -m discover -w domain && sudo sniper -f /usr/share/sniper/loot/domain/lyse/domains/targets.txt -m airstrike
```

![sn1per in Airstrike mode](<../../../.gitbook/assets/image (41).png>)

## ARP Scan

```
arp-scan --interface=wlan0 --localnet
arp-scan --interface=wlan0 10.0.1.0/24
```

More Info:

* [https://www.blackmoreops.com/2015/12/31/use-arp-scan-to-find-hidden-devices-in-your-network/](https://www.blackmoreops.com/2015/12/31/use-arp-scan-to-find-hidden-devices-in-your-network/)
* [https://tools.kali.org/information-gathering/arp-scan](https://tools.kali.org/information-gathering/arp-scan)

## NetDiscover

```
netdiscover -i wlan0 -r range
```

{% hint style="info" %}
`-r range`: scan a given range instead of auto scan. 192.168.6.0/24,/16,/8
{% endhint %}

```
netdiscover -i wlan0 -p -f -P -L
```

{% hint style="info" %}
`-P` print results in a format suitable for parsing by another program and stop after active scan

`-L` similar to `-P` but continue listening after the active scan is completed

`-f` enable fastmode scan, saves a lot of time, recommended for auto

`-p` passive mode: do not send anything, only sniff
{% endhint %}



## HackerTarget Tools

**Repo:** [https://hackertarget.com/ip-tools/](https://hackertarget.com/ip-tools/)

**Info:** The following are a collection of online IP Tools that can be used to quickly get information about IP Addresses, Web Pages and DNS records.

These tools are placed here to be a quick reference whether you are assessing your organizations systems, or popping boxes on a penetration testing engagement.

Reporting

## Nmap Grep

Comprehensive parsing script for grepable Nmap output files. Provides a summary table, split hosts files, and URLs for web and SMB hosts.

**nmap-grep.sh** is meant for parsing grepable Nmap output files (-oG). The file must be the first parameter. **--out-dir** can be used to specify a custom output directory. If not output directory is given, **nmap-grep-YYYY-MM-DD-HH-MM-SS** will be created.

* git clone [https://github.com/actuated/nmap-grep](https://github.com/actuated/nmap-grep)
* ./nmap-grep.sh **output-nmap.gnmap** \[--out-dir \[outputdirectory]] \[\[options]]
  * This script performs the following actions, which each have different options to flag them as disabled.
  * Create a summary table for open ports as summary.txt, including the IP, port, tcp/udp, protocol, and any version information. This can be disabled with **--no-summary**.
  * Create files for each open port, listing each IP with that port open on a separate line. By default, these files will be named \[port]-\[tcp/udp]-hosts.txt. This can be disabled with **--no-split**.
  * Rename split hosts files for common ports and services. For example, **21-tcp-hosts.txt** becomes **ftp-hosts.txt**. This can be disabled with **--no-label-split**.
  * Create **web-urls.txt**, with URLs for every open TCP 80, 443, 8080, and 8443 service. This can be disabled with **--no-web-urls**.
  * Create **smb-urls.txt**, with URLs for every open TCP 445 service. This can be disabled with **--no-smb-urls**.
  * Create **up-hosts.txt**, listing every host that reported as "up". This can be disabled with **--no-up**.

## awesome-nmap-grep

A collection of awesome, grep-like commands for the nmap greppable output (-oG) format. This repository aims to serve as a quick reference to modify the output into readable formats.

All of the below commands assume the output was saved to a file called **output.grep**. The example command to produce this file as well as the sample outputs was: **nmap -v --reason 127.0.0.1 -sV -oG output.grep -p-**.

Finally, the **NMAP\_FILE** variable is set to contain **output.grep**.

### count number of open ports

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d' ' -f2,4- | sed -n -e 's/Ignored.\*//p' | awk -F, '{split($0,a," "); printf "Host: %-20s Ports Open: %d\n" , a\[1], NF}' | sort -k 5 -g

#### output

Host: 127.0.0.1 Ports Open: 16

### print the top 10 ports

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d' ' -f4- | sed -n -e 's/Ignored.\*//p' | tr ',' '\n' | sed -e 's/^\[ \t]\*//' | sort -n | uniq -c | sort -k 1 -r | head -n 10

#### output

1 9001/open/tcp//tor-orport?///

1 9000/open/tcp//cslistener?///

1 8080/open/tcp//http-proxy///

1 80/open/tcp//http//Caddy/

1 6379/open/tcp//redis//Redis key-value store/

1 631/open/tcp//ipp//CUPS 2.1/

1 6234/open/tcp/////

1 58377/filtered/tcp/////

1 53/open/tcp//domain//dnsmasq 2.76/

1 49153/open/tcp//mountd//1-3/

### top service identifiers

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d ' ' -f4- | tr ',' '\n' | sed -e 's/^\[ \t]\*//' | awk -F '/' '{print $7}' | grep -v "^$" | sort | uniq -c | sort -k 1 -nr

#### output

2 Caddy

2 1-3 (RPC 100005)

1 dnsmasq 2.76

1 Redis key-value store

1 OpenSSH 6.9 (protocol 2.0)

1 MySQL 5.5.5-10.1.14-MariaDB

1 CUPS 2.1

### top service names

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d ' ' -f4- | tr ',' '\n' | sed -e 's/^\[ \t]\*//' | awk -F '/' '{print $5}' | grep -v "^$" | sort | uniq -c | sort -k 1 -nr

#### output

2 mountd

2 http

1 unknown

1 tor-orport?

1 ssl|https

1 ssh

1 redis

1 mysql

1 ipp

1 http-proxy

1 domain

1 cslistener?

### hosts and open ports

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d' ' -f2,4- | sed -n -e 's/Ignored.\*//p' | awk '{print "Host: " $1 " Ports: " NF-1; $1=""; for(i=2; i<=NF; i++) { a=a" "$i; }; split(a,s,","); for(e in s) { split(s\[e],v,"/"); printf "%-8s %s/%-7s %s\n" , v\[2], v\[3], v\[1], v\[5]}; a="" }'

#### output

Host: 127.0.0.1 Ports: 16

open tcp/22 ssh

open tcp/53 domain

open tcp/80 http

open tcp/443 https

open tcp/631 ipp

open tcp/3306 mysql

open tcp/4767 unknown

open tcp/6379

open tcp/8080 http-proxy

open tcp/8081 blackice-icecap

open tcp/9000 cslistener

open tcp/9001 tor-orport

open tcp/49152 unknown

open tcp/49153 unknown

filtered tcp/54695

filtered tcp/58369

### banner grab

* NMAP\_FILE=**output-nmap.gnmap**
* egrep -v "^#|Status: Up" $NMAP\_FILE | cut -d ' ' -f2,4- | awk -F, '{split($1,a," "); split(a\[2],b,"/"); print a\[1] " " b\[1]; for(i=2; i<=NF; i++) { split($i,c,"/"); print a\[1] c\[1] \}}' | xargs -L1 nc -v -w1

#### output

found 0 associations

found 1 connections:

&#x20;1: flags=82\<CONNECTED,PREFERRED>

&#x20;outif lo0

&#x20;src 127.0.0.1 port 52224

&#x20;dst 127.0.0.1 port 3306

&#x20;rank info not available

&#x20;TCP aux info available

Connection to 127.0.0.1 port 3306 \[tcp/mysql] succeeded!

Y

5.5.5-10.1.14-MariaDB�uds9^MIf��!?�EgVZ>iv7KTD7mysql\_native\_passwordfound 0 associations

nc: connectx to 127.0.0.1 port 54695 (tcp) failed: Connection refused

nc: connectx to 127.0.0.1 port 58369 (tcp) failed: Connection refused

## SMB security level

* nmap --script smb-security-mode.nse -p 445 **\<PORT> \<TARGET>**
* nmap -sU -sS --script smb-security-mode.nse -p U:137,T:139,445
* nmap -p445 --script smb-protocols \<TARGET>

Info: [http://nmap.org/nsedoc/scripts/smb-security-mode.html](http://nmap.org/nsedoc/scripts/smb-security-mode.html)

## NetBIOS Scanner

### NetBIOS Scanner

* [http://www.nirsoft.net/utils/netbios\_scanner.html](http://www.nirsoft.net/utils/netbios\_scanner.html)

### Nmap nbstat

* nmap -sU --script nbstat.nse -p137 \<host>
  * [https://nmap.org/nsedoc/scripts/nbstat.html](https://nmap.org/nsedoc/scripts/nbstat.html)

### Metasploit

* use auxiliary/scanner/smb/smb\_version
* use auxiliary/scanner/smb/smb\_enumshares
* use auxiliary/scanner/smb/smb\_lookupsid
* use auxiliary/scanner/smb/smb\_enumusers

Web

## ANALYZE

### CORStest

**Repo:** [https://github.com/RUB-NDS/CORStest](https://github.com/RUB-NDS/CORStest)

**Info:** A simple CORS misconfiguration scanner

* python \~/tools/CORStest/corstest.py **domainfile.txt**

## WEB CONTENT

###



## Web Services

### WSSAT

**Repo:** [https://github.com/YalcinYolalan/WSSAT](https://github.com/YalcinYolalan/WSSAT)

**Info:** WSSAT is an open source web service security scanning tool which provides a dynamic environment to add, update or delete vulnerabilities by just editing its configuration files. This tool accepts WSDL address list as input file and for each service, it performs both static and dynamic tests against the security vulnerabilities. It also makes information disclosure controls. With this tool, all web services could be analysed at once and the overall security assessment could be seen by the organization.

## Detectar WAF

### WAFw00f

&#x20;Descargar [https://github.com/EnableSecurity/wafw00f](https://github.com/EnableSecurity/wafw00f)

&#x20;sudo python setup.py install

&#x20;wafw00f \<URL>

![](../../../.gitbook/assets/3.png)

### nmap http-waf-detect

info: [https://nmap.org/nsedoc/scripts/http-waf-detect.html](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

&#x20;nmap -p \<PORT> --script http-waf-detect \<HOST>

nmap -p \<PORT> --script http-waf-detect --script-args="http-waf-detect.aggro,http-waf-detect.uri=**/testphp.vulnweb.com/artists.php**" \<HOST>

### nmap http-waf-fingerprint

info: [https://nmap.org/nsedoc/scripts/http-waf-fingerprint.html](https://nmap.org/nsedoc/scripts/http-waf-fingerprint.html)

&#x20;nmap -p \<PORT> --script=http-waf-fingerprint \<targets>

nmap -p \<PORT> --script=http-waf-fingerprint --script-args http-waf-fingerprint.intensive=1 \<HOST>

![](../../../.gitbook/assets/4.png)

## HTTP.Sys

&#x20;nmap -sV -Pn --script http-vuln-cve2015-1635 --script-args uri='/anotheruri/' -p \<PORT> \<TARGET>

&#x20;nmap -Pn --script http-vuln-cve2015-1635.nse -p \<PORT> \<TARGET>

## ENUMERAR ENCRIPCIÓN RDP:

* nmap -p **\<PORT>** -Pn -v --script rdp-enum-encryption **\<TARGET>**

Info: [http://nmap.org/nsedoc/scripts/rdp-enum-encryption.html](http://nmap.org/nsedoc/scripts/rdp-enum-encryption.html)

## WinShock

* bash /root/BASE4tools/winshock\_test.sh \<host> \<port>

## Enumerar Métodos HTTP

* nmap --script http-methods \<target>
* nmap --script http-methods --script-args http.url-path='/website' \<target>

Info: [https://nmap.org/nsedoc/scripts/http-methods.html](https://nmap.org/nsedoc/scripts/http-methods.html)

## Enumerar recursos SMB

nmap -sU -sS --script smb-enum-shares.nse -p U:137,T:139,445

## Poner Placa Modo Monitor

Nos mostrará, por pantalla, información de las interfaces de red que tengamos en nuestro pc, tanto Ethernet como Wireless. Además podemos añadir al comando, el nombre de una interface y una opción para obtener más datos y variables.

* iwconfig

Nos dará información de la configuración del dispositivo, nombrado como **wlan0**

También le podemos añadir una opción y usarlo para poner la tarjeta en modo monitor

* iwconfig wlanX mode monitor

O modo manager

* iwconfig wlanX mode manager

Para encender la radio de nuestro dispositivo wifi, donde **XX** será un valor numérico para poder subir la potencia de salida de nuestro dispositivo wifi (siempre que sea compatible). Tendremos que haber cargado previamente los módulos CRDA (se encuentran en la carpeta optional)

* iwconfig wlanX power on
* iwconfig wlanX TX power XX

Para apagar la radio de nuestro dispositivo wifi

* iwconfig wlanX power off

Con este comando “levantaremos” nuestro dispositivo para que sea reconocido por el sistema

* ifconfig wlanX up

Con este comando tumbaremos nuestro dispositivo, para que el sistema deje de reconocerlo

Digamos que estos comandos se usan para “reiniciar” los dispositivos inalámbricos cuando vamos a darles un uso distinto o en herramientas distintas dentro de WIFISLAX.

* ifconfig wlanX down

Este comando no listara todos los dispositivos PCI reconocidos por el sistema

* lspci

Este nos listara todos los dispositivos USB reconocidos por el sistema

* lsusb

Con este comando podremos activar el cliente DHCP y así poder conectarnos a una red, recibiendo, dirección IP, rutas etc.

* dhcpcd

Nos listara los módulos que tenemos instalados en el sistema

* lsmod

## SUITE AIRCRACK-NG

Esta es la biblia de la auditoria de seguridad wireless. En esta suite se basan casi todas (por no decir todas) las herramientas de auditorías que se utilizan hoy en día, para los ataques a los protocolos de seguridad y encriptación de los routers existentes, véanse Gui´s, Script etc. Y como tal es de obligado conocimiento para cualquiera que se quiera adentrar en este mundo, una vez que conozcamos este conjunto de herramientas entenderemos mejor el funcionamiento de esos script, en los que nos dedicamos a pulsar números y obtenemos una clave.

### AIRMON-NG

Este comando, usado tal cual nos mostrara información sobre el chip de nuestro dispositivo wireless, si le añadimos la variable start/stop nos pondrá nuestro dispositivo en modo monitor o modo manager según la que usemos.

* airmon-ng

Poner modo monitor

* airmon-ng start wlanX

Parar modo monitor

* airmon-ng stop monX

### AIRODUMP-NG

Se usa para capturar los datos transmitidos a través de las ondas wifi, concretamente las balizas mandadas por los routers cercanos (Beacons) y los IVs (vectores iniciales) de los paquetes wep.

* airodump-ng \<opción> \[dispositivo]

Esta cadena nos mostrara todas las redes wifi al alcance, con su Bssid, essid, power,chanel, tipo de encriptación. Etc

* airodump-ng monX

## Ataque de denegación de servicio "Slow HTTP"

### Test

sudo nmap --script http-slowloris-check -p 443 \<target>

NOTA: A VECES HAY QUE EJECUTARLO UN PAR DE VECES PARA QUE VERIFIQUE LA VULNERABILIDAD

![](../../../.gitbook/assets/11.png)

### Exploit

Formulario HTML sin protección contra CSRF

nmap -p80 --script http-csrf.nse \<target>

## Kismet to CSV

El Kismet en sus últimas versiones no permite arrojar los resultado a CSV y esto es imprescindible para las auditorías y centralización de datos.

1. Para pasar de los archivos **netxml** a **csv** es necesario emplear el siguiente script: [https://github.com/MichaelCaraccio/NetXML-to-CSV](https://github.com/MichaelCaraccio/NetXML-to-CSV)
2. Si ese script ya no está más online, la copia está en [https://drive.google.com/open?id=0B6NJMB-tSNA5VVk3aGNVcElVb0U](https://drive.google.com/open?id=0B6NJMB-tSNA5VVk3aGNVcElVb0U)
3. Una vez descargado la sintaxis es la siguiente:

### Convert every network into a csv file :

$ python3 main.py inputfile.netxml result.csv

### Convert only WEP encryption networks :

$ python3 main.py inputfile.netxml result.csv WEP

### Convert only WPA+AES-CCM encryption networks :

$ python3 main.py inputfile.netxml result.csv WPA+AES-CCM

## Linux

### Listar puertos abiertos

Están las siguientes opciones:

_netstat -pln_

\# **-l** will list listening ports, **-p** will also display the process, **-n** will show port numbers instead of names. Add **-t** to only show TCP ports.

_lsof -i -P_

**-P** lists the port number rather than the name taken from /etc/services Run as root, though, this will provide you with a list of all active network connections and their status (listening, established, etc).

### Verificar consultas NTP mode 6

ntpq -c rv DIRECCION\_IP
